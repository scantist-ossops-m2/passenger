/*
 *  Phusion Passenger - https://www.phusionpassenger.com/
 *  Copyright (c) 2015-2018 Phusion Holding B.V.
 *
 *  "Passenger", "Phusion Passenger" and "Union Station" are registered
 *  trademarks of Phusion Holding B.V.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
#ifndef _PASSENGER_API_ACCOUNT_UTILS_H_
#define _PASSENGER_API_ACCOUNT_UTILS_H_

#include <vector>
#include <string>
#include <cstddef>

#include <oxt/macros.hpp>
#include <boost/config.hpp>

#include <ConfigKit/ConfigKit.h>
#include <Exceptions.h>
#include <StaticString.h>
#include <FileTools/PathManip.h>
#include <FileTools/FileManip.h>
#include <Utils.h>
#include <StrIntTools/StrIntUtils.h>
#include <JsonTools/JsonUtils.h>

namespace Passenger {
namespace ApiAccountUtils { // Avoid conflict with classes of the same name in ApiServerUtils.h, until we've migrated everything

using namespace std;


/*
 * This file implements handling of API accounts.
 *
 * The various PassengerAgent ApiServers can be accessed through HTTP sockets.
 * Authenticating and authorizating clients is handled through API accounts.
 * Each ApiServer embeds an API account database. Each account contains a
 * username, password and a privilege level.
 *
 * The API account and the API account database are represented by the
 * `ApiAccount` and `ApiAccountDatabase` classes, respectively. Both of them
 * are supposed to be used in an immutable manner.
 *
 * Users can specify API accounts in two formats:
 *
 *  1. Through a JSON array:
 *
 *       [
 *         {
 *           "username": "foo",
 *
 *           // One of these must exist:
 *           "password": "bar",
 *           "password_file": "/filename"
 *
 *           "level": "readonly" | "full"   // Optional; "full" is defeault
 *         },
 *         ...
 *       ]
 *
 *  2. Through a list of description strings, each in the form of:
 *
 *       [LEVEL]:USERNAME:PASSWORDFILE
 *
 *     LEVEL is one of:
 *
 *       readonly    Read-only access
 *       full        Full access (default)
 *
 *
 * This file contains three functions for operating on input supplied in
 * one of the two formats (scroll down for descriptions):
 *
 *  - validateAuthorizationsField() -- checks whether a JSON array conforms to the above format.
 *  - normalizeApiAccountJson() -- normalizes an item in the JSON array into a consistent format.
 *  - parseApiAccountDescription() -- parses a description string into a JSON object.
 *
 * An authorizations JSON array is considered *valid* if it passes `validateAuthorizationsField()`.
 * An authorization JSON object is considered *normalized* if it conforms to the output format
 * generated by `normalizeApiAccountJson()`.
 *
 * Valid and normalized are orthogonal concepts. One does not imply the other.
 */


inline json::value parseApiAccountDescription(const StaticString &description);


/**
 * Checks whether an authorization JSON array conforms to the specified format.
 *
 * A JSON array that passes this function is *valid*, although not necessarily *normalized*.
 */
static void
validateAuthorizationsField(const string &key, const ConfigKit::Store &config,
	vector<ConfigKit::Error> &outputErrors)
{
	typedef ConfigKit::Error Error;

	if (config[key].is_null()) {
		return;
	}

	const json::array &authorizations = config[key].get_array();
	json::array::const_iterator it, end = authorizations.end();
	vector<ConfigKit::Error> errors;

	for (it = authorizations.begin(); it != end; it++) {
		const json::value &vauth = *it;

		if (vauth.is_string()) {
			try {
				parseApiAccountDescription(vauth.as_string());
			} catch (const ArgumentException &e) {
				errors.push_back(Error("'{{" + key + "}}' contains an invalid authorization description ("
					+ vauth.as_string() + "): " + e.what()));
			}
		} else if (vauth.is_object()) {
			const json::object &auth = it->get_object();
			if (auth.contains("username")) {
				if (!auth.at("username").is_string()) {
					errors.push_back(Error("All usernames in '{{" + key + "}}' must be strings"));
				} else if (auth.at("username").as_string() == "api") {
					errors.push_back(Error("'{{" + key + "}}' may not contain an 'api' username"));
				}
			} else {
				errors.push_back(Error("All objects in '{{" + key + "}}' must contain the 'username' key"));
			}

			if (auth.contains("password")) {
				if (!auth.at("password").is_string()) {
					errors.push_back(Error("All passwords in '{{" + key + "}}' must be strings"));
				}
				if (auth.contains("password_file")) {
					errors.push_back(Error("Entries in '{{" + key + "}}' must contain either the"
						" 'password' or the 'password_file' field, but not both"));
				}
			} else if (auth.contains("password_file")) {
				if (!auth.at("password_file").is_string()) {
					errors.push_back(Error("All 'password_file' fields in '{{" + key + "}}' must be strings"));
				}
			} else {
				errors.push_back(Error("All objects in '{{" + key + "}}' must contain either the"
					" 'password' or 'password_file' key"));
			}

			if (auth.contains("level")) {
				if (!auth.at("level").is_string() || (
					auth.at("level").as_string() != "readonly"
					&& auth.at("level").as_string() != "full"))
				{
					errors.push_back(Error("All 'level' fields in '{{" + key + "}}' must be either"
						" 'readonly' or 'full'"));
				}
			}
		} else {
			errors.push_back(Error("'{{" + key + "}}' may only contain strings or objects"));
		}
	}

	errors = ConfigKit::deduplicateErrors(errors);
	outputErrors.insert(outputErrors.end(), errors.begin(), errors.end());
}

/**
 * Given a *valid* authorizations JSON array, this function
 * turns that array into a consistent format.
 *
 * For example it ensures that, if the "level" field does
 * not exist, it is inserted with the default value.
 */
inline json::value
normalizeApiAccountJson(const json::value &json) {
	if (json.is_string()) {
		return parseApiAccountDescription(json.as_string());
	} else {
		json::object doc = json.get_object();
		if (doc.contains("password_file")) {
			doc["password_file"] = absolutizePath(doc["password_file"].as_string());
		}
		if (!doc.contains("level")) {
			doc["level"] = "full";
		}
		return doc;
	}
}

inline json::value
normalizeApiAccountsJson(const json::value &json) {
	json::array doc = json.get_array();
	json::array::iterator it, end = doc.end();
	for (it = doc.begin(); it != end; it++) {
		*it = normalizeApiAccountJson(*it);
	}
	return doc;
}

/**
 * Parses an API account description string into a *valid* (but not necessarily
 * *normalized*) JSON object.
 *
 * @throws ArgumentException One of the input arguments contains a disallowed value.
 */
inline json::value
parseApiAccountDescription(const StaticString &description) {
	json::object json;
	vector<StaticString> args;

	split(description, ':', args);

	if (args.size() == 2) {
		json["username"] = args[0].toString();
		json["password_file"] = args[1].toString();
		json["level"] = "full";
	} else if (args.size() == 3) {
		json["username"] = args[1].toString();
		json["password_file"] = args[2].toString();
		if (args[0] == "full" || args[0] == "readonly") {
			json["level"] = args[0].toString();
		} else {
			throw ArgumentException("'level' field must be either 'full' or 'readonly'");
		}
	} else {
		throw ArgumentException(string());
	}

	if (OXT_UNLIKELY(json["username"].as_string() == "api")) {
		throw ArgumentException("the username 'api' is not allowed");
	}

	return json;
}

struct ApiAccount {
	string username;
	string password;
	bool readonly;

	/**
	 * Constructs an ApiAccount.
	 *
	 * @params doc An *normalized* authorization JSON object.
	 */
	ApiAccount(const json::value &vdoc) {
		const json::object &doc = vdoc.get_object();
		username = getJsonStringField(doc,"username");
		if (doc.contains("password")) {
			password = getJsonStringField(doc,"password");
		} else {
			password = strip(unsafeReadFile(getJsonStringField(doc,"password_file")));
		}
		readonly = doc.at("level").as_string() == "readonly";
	}
};

class ApiAccountDatabase {
private:
	vector<ApiAccount> database;

public:
	ApiAccountDatabase() { }

	/**
	 * Constructs an ApiAccountDatabase.
	 *
	 * @param authorizations A *normalized* JSON array of authorization objects.
	 */
	ApiAccountDatabase(const json::value &vauthorizations) {
		const json::array &authorizations = vauthorizations.get_array();
		database.reserve(authorizations.size());

		json::array::const_iterator it, end = authorizations.end();
		for (it = authorizations.begin(); it != end; it++) {
			const json::value &auth = *it;
			database.push_back(ApiAccount(auth));
		}
	}

	bool empty() const {
		return database.empty();
	}

	const ApiAccount *lookup(const StaticString &username) const {
		vector<ApiAccount>::const_iterator it, end = database.end();

		for (it = database.begin(); it != end; it++) {
			if (it->username == username) {
				return &(*it);
			}
		}

		return NULL;
	}

	void swap(ApiAccountDatabase &other) BOOST_NOEXCEPT_OR_NOTHROW {
		database.swap(other.database);
	}
};


} // namespace ApiAccountUtils
} // namespace Passenger

#endif /* _PASSENGER_API_ACCOUNT_UTILS_H_*/
